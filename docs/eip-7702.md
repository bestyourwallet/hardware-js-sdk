
# EIP-7702 技术指南

## 1. EIP-7702 核心概念

### 1.1 技术原理

EIP-7702 通过临时委托机制让普通钱包（EOA）在单次交易中获得智能合约能力：

- 临时授权：EOA 在交易执行期间临时"借用"智能合约代码
普通 EOA，不改变账户状态
- 向后兼容：现有交易类型完全不受影响

### 1.2 智能合约钱包 vs 普通钱包

**普通钱包（EOA）**：
- 由私钥直接控制的账户
- 只能发送简单交易（转账、合约调用）
- 无法批量操作，每个操作需要单独交易
- Gas 费用高（多次交易累积）

**智能合约钱包**：
- 由智能合约代码控制的账户
- 支持复杂逻辑和批量操作
- 需要预先部署，成本高
- 兼容性问题，需要 DApp 专门适配

**EIP-7702 的革新**：
- 让普通钱包临时获得智能合约能力
- 无需预部署，零额外成本
- 完全向后兼容现有生态
- 交易后自动恢复为普通钱包

### 1.3 核心优势

| 特性 | 普通钱包（EOA） | 智能合约钱包 | EIP-7702 |
|------|----------------|-------------|----------|
| **部署成本** | 无 | 高（需预部署） | 无 |
| **批量操作** | ❌ | ✅ | ✅ |
| **复杂逻辑** | ❌ | ✅ | ✅ |
| **兼容性** | ✅ | 需适配 | ✅ |
| **使用门槛** | 低 | 高 | 低 |

### 1.3 应用场景

- **批量转账**：一次交易向多个地址转账
- **DeFi 复合操作**：swap + 流动性挖矿 + 质押，一次完成
- **Gas 费优化**：多个操作合并，显著降低总 Gas 消耗

## 2. 协议变动说明

### 2.1 交易结构变动

EIP-7702 在现有 EIP-1559 交易基础上新增 authorizationList 参数：

```typescript
// EIP-1559 交易结构
type EIP1559Transaction = {
  to: string;
  value: string;
  data: string;
  chainId: number;
  nonce: string;
  gasLimit: string;
  maxFeePerGas: string;
  maxPriorityFeePerGas: string;
};

// EIP-7702 交易结构（新增 authorizationList）
type EIP7702Transaction = EIP1559Transaction & {
  authorizationList: Authorization[];  // 新增字段
};

type Authorization = {
  chainId: number;       // 授权链 ID，比如 base、evm 主网
  address: string;       // 委托合约地址
  nonce: string;         // 授权 nonce
  addressN?: number[];   // 可选：用于授权签名的 HD Path（由硬件生成授权签名时使用）

  r?: string;            // 可选：授权签名 r 值（若已外部签名）
  s?: string;            // 可选：授权签名 s 值（若已外部签名）
  yParity?: string;      // 可选：授权签名奇偶性标识（若已外部签名）
};
```

**r, s, yParity 签名参数说明**：
- **作用**：证明用户确实授权了指定合约（类似数字签名）
- **安全性**：必须由用户私钥生成，无法伪造（目前的设计是，既可以外部传递，也可以硬件内部生成）


> 重要说明（to 与授权地址）：
> - 对于 EIP-7702 的 SET_CODE_TX_TYPE（type: 0x04）交易，to 应为发起者的 EOA 地址；authorizationList.address 才是委托合约地址。
> - 在完成首次委托后，后续大多数操作可以通过普通 EIP-1559 交易直接对该 EOA 地址发起调用（由委托代码执行），无需再包含 authorizationList。参考：OpenZeppelin EOA Delegation、QuickNode EIP-7702 指南。


## 3. 实现方案对比与安全分析

### 3.1 EIP-7702 攻击案例分析

**安全报告参考**：
- SlowMist - 2025 Q2 被盗资金分析报告

**攻击原理**：
攻击者利用 EIP-7702 的委托机制，通过双重欺骗手段盗取用户资产：

```typescript
// 攻击者构造的恶意交易（示意，仅展示关键字段）
const maliciousTransaction = {
  to: '<victim EOA address>', // 7702 SET_CODE_TX_TYPE 的 to 为发起者的 EOA 地址
  value: '0x0',
  authorizationList: [{
    chainId: 1,
    address: '0xC83De81A', // 恶意委托合约地址（authorizationList.address）
    nonce: '0x1',
    r: '0x...', s: '0x...', yParity: '0x0'
  }],
  // data 可能被注入实际调用（例如 approve + swap），详见 3.1.2
};
```


### 3.1.2 授权 + 执行合并（data 注入）

- 原理：单笔 7702 交易会在执行前先处理 authorizationList（写入 0xef0100+地址 的委托指示符），随后按 data 执行对 EOA 的调用。因此，攻击者可将“授权 + 执行”合并为单次交易，误导用户以为只是授权。
- 影响：用户可能在不知情的情况下同时批准/交换/转移资产（常见为 approve + swap）。
- 风险识别与缓解：
  - 授权-only 场景期望 data 为 '0x'；若检测到非空 data，应明显提示或拒绝（详见硬件策略）。
  - 对 data 解码显示关键函数与代币影响（例如代币授权额度、目标合约）。
  - 对非白名单合约/复杂批量调用给出高风险提示。
- 参考资料：
  - OpenZeppelin Docs - EOA Delegation（首次 7702 交易可在授权后执行 data）
    https://docs.openzeppelin.com/contracts/5.x/eoa-delegation
  - EIP-7702 深入解析（HackMD）示例：单笔交易内“委托 + 添加签名密钥”，说明初次授权交易可附带执行
    https://hackmd.io/@colinlyguo/SyAZWMmr1x
  - GoPlus Security：EIP-7702 钓鱼风险综述（讨论“升级/授权”场景下的钓鱼与防护）
    https://goplussecurity.medium.com/understanding-eip-7702-phishing-attacks-a-comprehensive-guide-to-protection-strategies-for-wallets-8e8372e3d5ea


> 硬件当前实现补充：当委托合约不属于 revoke 且未配置 initial_data 时，固件要求授权-only 流程的 data 为空（'0x'）；若检测到非空 data 将直接报错并拒绝（错误信息：Calldata is expected to be empty）。

**攻击流程**：
1. **诱导访问**：用户被引导到伪造的 DeFi 网站
2. **伪装操作**：网站显示"升级钱包"或"Uniswap 交易"
3. **双重欺骗**：交易发送到可信合约，但授权给恶意合约
4. **资金盗取**：恶意合约获得控制权，批量转移所有资产

**已知恶意合约地址**：
- `0xC83De81A`
- `0x33dAD2b`

### 3.2 硬件钱包安全实现

**核心安全特点**：
- 一次性处理：硬件设备同时完成授权签名和交易签名
- 白名单防护：仅允许 authorizationList.address 属于已注册/审计的委托合约；授权-only 流程期望 data 为 '0x'（为空），否则强提示或拒绝
- authorizationList只允许授权一个地址：简化授权处理

**安全防护机制**：

**1. 硬件白名单验证**
```python
# OneKey 固件硬编码白名单
WHITELIST = {
    "Revoke": "0x0000000000000000000000000000000000000000",
    "OKX": "0x80296FF8D1ED46f8e3C7992664D13B833504c2Bb",
    "MetaMask": "0x63c0c19a282a1B52b07dD5a65b58948A07DAE32B",
    "Simple7702": "0x4Cd241E8d1510e30b2076397afc7508Ae59C66c9"
}

# 硬件验证逻辑
async def validate_delegate(ctx, delegate_addr, delegate_chain_id):
    if not is_registered_delegator(delegate_chain_id, delegate_addr):
        await show_invalid_delegate(ctx)
        raise wire.DataError("Authorization address not in registered delegators")
```

**2. metamask 软钱包以及硬件钱包实现对比**

| 攻击场景 | MetaMask 软件钱包 | OneKey 硬件钱包 |
|---------|------------------|----------------|
| **恶意合约 0xC83De81A** | ❌ 可能被授权 | ✅ 硬件直接拒绝 |
| **未知恶意合约** | ❌ 依赖用户判断 | ✅ 白名单外全部拒绝 |

**授权条目支持差异**

**OneKey 限制**：
```python
# OneKey 固件当前限制
if len(msg.authorization_list) > 1:
    raise wire.DataError("Only support Self-sponsoring transaction now")
```

**限制原因分析**：
- **安全防护**：单个授权条目降低攻击复杂度，更容易验证
- **用户体验**：简化用户确认流程，减少误操作风险
- **实现复杂度**：避免复杂的多授权验证逻辑，确保系统稳定性

**MetaMask 支持**：
- ✅ 支持多个授权条目
- ✅ 支持复杂的权限限制（Caveats）
- ✅ 支持跨合约的复杂操作
- 有可能会授权给恶意合约

### 3.3 主流两阶段使用模式（以常见钱包为例）

- 首次：发送 EIP-7702 交易（type: 0x04，包含 `authorizationList`），将 EOA 升级为委托执行模型（可选择携带 data 执行）
- 后续：发送普通 EIP-1559 交易直接对 EOA 地址发起调用（由委托代码执行），无须再附带 `authorizationList`

该两阶段模式的优势：
- 避免每次都进行 7702 授权的额外开销
- 提升后续操作的交互与性能
- 利用委托代码的持久状态与复杂逻辑

#### 示例：首次授权 + 后续普通交易

- 首次授权（SET_CODE_TX_TYPE/type: 0x04）：
  https://etherscan.io/tx/0xf54680ea559587c3fa711e876291da4d4481bb452fa765441b4dfc107b45d0c6
- 授权后，智能合约账号进行 swap（普通 EIP-1559 交易，包含 approve + swap）：
  https://etherscan.io/tx/0xb8874a72d2858270531757f758aac54b9f21f05e6d220e80414652e0034fdd0c


## 4. 支持的安全合约

OneKey 硬件钱包支持以下三种经过安全审计的合约地址，以及支持进行revoke：

**Simple7702Account**
- **合约地址**：`0x4Cd241E8d1510e30b2076397afc7508Ae59C66c9`
- **源码仓库**：https://github.com/eth-infinitism/account-abstraction
- **功能特点**：基础 EIP-7702 实现，Gas 消耗低
- **适用场景**：个人用户的简单批量操作

**MetaMask Account**
- **合约地址**：`0x63c0c19a282a1B52b07dD5a65b58948A07DAE32B`
- **源码查看**：https://github.com/MetaMask/accounts.git
- **功能特点**：支持复杂委托机制、权限控制、代付 Gas
- **适用场景**：与 MetaMask 集成使用，支持复杂 DeFi 操作

**OKX WalletCore**
- **合约地址**：`0x80296FF8D1ED46f8e3C7992664D13B833504c2Bb`
- **源码仓库**：https://github.com/okx/wallet-core
- **功能特点**：模块化设计，三种执行类型，交易优化
- **适用场景**：高频交易、批量资产管理

## 4. 兼容性问题

### 4.1 关键差异：用户确认次数

### 4.2 实现现状与限制（OKX / MetaMask）

- OKX（WalletCore）
  - 现状：目前仅实现 EIP-7702 升级能力（SET_CODE_TX_TYPE 授权写入）。完整的 WalletCore-Relayer 服务架构因产品优先级暂未部署上线。
  - 影响：暂不提供端到端的中继/代付能力；用户可完成首次授权与后续普通交易，但不依赖 OKX 自身的 relayer。

- MetaMask
  - 现状：其授权流程与我们当前交互存在兼容性问题（需要二次签名/二次确认）。该问题已知且暂时搁置，待官方修复或协同方案后再推进。
  - 影响：升级体验不佳；我们在文档与实现中已弱化与中继相关的细节，后续将视官方进展再恢复对接。


**OneKey 硬件钱包流程**：
- **用户确认次数**：1 次
- **处理方式**：硬件设备一次性完成授权+交易签名
- **用户体验**：在硬件设备上看到完整交易信息，确认一次即可

**OneKey 处理示例**：
用户构造包含 authorizationList 的完整交易，硬件设备同时显示授权合约地址和交易详情，用户在硬件设备上确认一次，即可完成整个流程。

**MetaMask  7702 升级确认流程**：
- **用户确认次数**：2 次
- **处理方式**：先签一次 authorizationList，再签一次广播交易
- **用户体验**：连续两次出现升级界面（这里目前是有问题的，需要 metamask 进行处理，具体上下文：https://onekeygroup.slack.com/archives/C04596CP3BN/p1756293294921909

## 5. 仓库架构与集成实现

### 5.1 仓库职责划分

**OneKey hardware-js-sdk**：
- **职责**：OneKey 硬件钱包的核心 SDK
- **功能**：提供与 OneKey 硬件设备通讯的底层接口
- **EIP-7702 实现**：处理硬件设备的 EIP-7702 交易签名

**MetaMask @metamask/accounts-monorepo**：
- **职责**：MetaMask 的账户管理核心库
- **功能**：实现各种 Keyring 接口，包括硬件钱包集成
- **EIP-7702 实现**：OneKey Keyring 的 EIP-7702 授权签名方法
- **集成 commit**：OneKey EIP-7702 集成实现

**MetaMask metamask-extension**：
- **职责**：MetaMask 浏览器扩展的主体应用
- **功能**：用户界面、交易管理、DApp 接口
- **EIP-7702 实现**：wallet_sendCalls 接口和用户交互逻辑
- **集成 commit**：MetaMask EIP-7702 扩展集成

### 5.2 集成架构流程

```
DApp 调用 wallet_sendCalls
    ↓
MetaMask Extension (metamask-extension)
    ↓
OneKey Keyring (@metamask/accounts-monorepo)
    ↓
OneKey Bridge (hardware-js-sdk)
    ↓
OneKey 硬件设备
```

**详细调用链路**：

```typescript
// 1. 在 @metamask/accounts-monorepo 中的 OneKey Keyring 实现
class OneKeyKeyring {
  async signEip7702Authorization(
    withAccount: string,
    authorization: EIP7702Authorization
  ): Promise<string> {
    const details = this.#accountDetailsFromAddress(withAccount);

    // 解构授权参数：[chainId, contractAddress, nonce]
    const [chainId, contractAddress, nonce] = authorization;

    // 构造完整的 EIP-7702 交易（示意）
    const transaction = {
      to: withAccount,            // EOA 地址（SET_CODE_TX_TYPE 写入 delegation）
      value: '0x0',
      data: '0x',                  // 授权-only 时 data 应为空
      chainId,
      nonce: Math.min(nonce - 1).toString(16),
      gasLimit: '0x520800',
      maxFeePerGas: '0x520800',
      maxPriorityFeePerGas: '0x520800',
      authorizationList: [{
        chainId,
        address: contractAddress,  // 委托合约地址
        nonce: nonce.toString(16)
      }]
    };

    // 调用 OneKey Bridge（桥接层）
    const response = await this.bridge.ethereumSignTransaction({
      path: details.hdPath,
      passphraseState: details.passphraseState ?? '',
      useEmptyPassphrase: isEmptyPassphrase(details.passphraseState),
      transaction
    });

    // 硬件返回的是签名字符串，直接返回
    if (response.success) {
      return response.payload.signature;
    }
    throw new Error(response.payload.error);
  }
}
```

**OneKey Bridge 内部实现**：
- **OneKeyWebBridge**：直接调用 `@ukeyfe/hd-web-sdk`
- **OneKeyOffscreenBridge**：通过 Chrome Extension 消息传递调用 SDK

```typescript
// OneKey Bridge 最终调用 OneKey hardware-js-sdk
class OneKeyWebBridge {
  async ethereumSignTransaction(
    params: Params<EVMSignTransactionParams>
  ): Promise<{ success: boolean; payload: EVMSignedTx | { error: string } }> {
    if (!this.sdk) {
      return {
        success: false,
        payload: { error: 'SDK not initialized', code: 800 }
      };
    }

    // 调用 OneKey hardware-js-sdk 的核心方法
    return await this.sdk.evmSignTransaction('', '', {
      ...params,
      skipPassphraseCheck: true
    });
  }
}
```

**OneKey 硬件设备处理**：

**1. hardware-js-sdk 层面的验证**：
```typescript
// packages/core/src/api/evm/latest/signTransaction.ts
export const evmSignTxEip7702 = async ({
  typedCall,
  addressN,
  tx,
  supportTrezor,
}: {
  typedCall: TypedCall;
  addressN: number[];
  tx: EVMTransactionEIP7702;
  supportTrezor?: boolean;
}) => {
  const {
    to, value, gasLimit, nonce, data, chainId,
    maxFeePerGas, maxPriorityFeePerGas, authorizationList
  } = tx;

  // 硬件当前只支持自赞助交易
  // 检查所有授权条目是否为自赞助
  const hasNonSelfSponsoring = authorizationList.some(
    auth =>
      // 如果为此授权提供了 addressN，它应该与交易签名者匹配
      auth.addressN && auth.addressN.join('/') !== addressN.join('/')
  );

  if (hasNonSelfSponsoring) {
    throw ERRORS.TypedError(
      HardwareErrorCode.CallMethodError,
      'Hardware currently only supports self-sponsoring EIP-7702 transactions. All authorization entries must be signed by the same account as the transaction.'
    );
  }

  // 构造硬件消息
  const message: EthereumSignTxEIP7702OneKey = {
    address_n: addressN,
    to: addHexPrefix(to),
    value: stripHexStartZeroes(value),
    gas_limit: stripHexStartZeroes(gasLimit),
    nonce: stripHexStartZeroes(nonce),
    data: data ? addHexPrefix(data) : undefined,
    chain_id: chainId,
    max_fee_per_gas: stripHexStartZeroes(maxFeePerGas),
    max_priority_fee_per_gas: stripHexStartZeroes(maxPriorityFeePerGas),
    authorization_list: authorizationList.map(auth => ({
      address_n: auth.addressN || [],
      chain_id: auth.chainId,
      address: addHexPrefix(auth.address),
      nonce: stripHexStartZeroes(auth.nonce),
      signature: auth.yParity !== undefined && auth.r && auth.s
        ? { y_parity: auth.yParity, r: auth.r, s: auth.s }
        : undefined,
    }))
  };

  // 调用硬件设备签名
  const response = await typedCall(
    'EthereumSignTxEIP7702OneKey',
    'EthereumTxRequestOneKey',
    message
  );

  return processTxRequest({
    typedCall,
    request: response.message,
    data: { chainId, ...tx }
  });
};
```

**2. 固件层面的验证**：
```python
# core/src/apps/ethereum/onekey/sign_tx_eip7702.py
def check_common_fields(msg: EthereumSignTxEIP7702) -> None:
    # ... 其他检查 ...

    if len(msg.authorization_list) == 0:
        raise wire.DataError("Authorization list is empty")
    if len(msg.authorization_list) > 1:
        raise wire.DataError("Only support Self-sponsoring transaction now")

    for authorization in msg.authorization_list:
        if authorization.chain_id not in (0, msg.chain_id):
            raise wire.DataError("Authorization chain ID invalid")
        if len(authorization.address) != 42:
            raise wire.DataError("Authorization address invalid, should start with 0x")
        # ... 更多验证逻辑 ...

async def validate_delegate(
    ctx: wire.Context, delegate_addr: str, delegate_chain_id: int
) -> None:
    if not is_registered_delegator(delegate_chain_id, delegate_addr):
        await show_invalid_delegate(ctx)
        raise wire.DataError("Authorization address not in registered delegators")
```
****


## 6. 硬件安全限制与作用（OneKey Firmware）

本节汇总 OneKey 设备端对 EIP-7702 的主要限制与设计动机，并给出核心代码位置，便于审计与演进。

- 白名单强制校验（仅允许已注册的委托合约地址）
  - 作用：降低“授权到恶意委托合约”的风险
  - 代码：core/src/apps/ethereum/onekey/eip7702_delegators.py（白名单表与初始 data 规则）；core/src/apps/ethereum/onekey/sign_tx_eip7702.py 中 validate_delegate

- 初始 data 规则（首次授权场景）
  - 作用：压缩“授权 + 执行合并（data 注入）”的风险面；兼容 OKX 的初始化流程
  - 规则：
    - Simple7702 / MetaMask：要求授权-only 的 data 为空（'0x'）
    - OKX：要求 data 初始块等于 0x8129fc1c（initialize() 方法选择器）
  - 代码：eip7702_delegators.py（为不同委托方配置 initial_data）；sign_tx_eip7702.py（对 msg.data_initial_chunk 与 initial_data 的匹配校验）

- 授权列表长度限制
  - 作用：降低实现与交互复杂度，减少出错与攻击面
  - 限制：仅支持单个 authorization 条目
  - 代码：core/src/apps/ethereum/onekey/sign_tx_eip7702.py → check_common_fields

- 授权 chainId 约束
  - 作用：避免跨链错配与重放
  - 限制：authorization.chain_id 必须为 0（通配）或等于交易 chain_id
  - 代码：core/src/apps/ethereum/onekey/sign_tx_eip7702.py → check_common_fields

- 授权 nonce 与数值边界
  - 作用：遵循 7702 的处理顺序与防重放；防止异常数值
  - 限制：
    - nonce < 2^64（EIP-2681 上限）
    - 当未提供外部签名且未提供 authorization.address_n（即由交易发起人“自签名”授权）时，要求 authorization.nonce = tx.nonce + 1
  - 代码：core/src/apps/ethereum/onekey/sign_tx_eip7702.py → check_common_fields

- 授权签名来源互斥
  - 作用：边界清晰，要么设备基于 HD Path 生成授权签名，要么使用外部提供的 r/s/y_parity
  - 限制：同一 authorization 不可同时包含 address_n 与 signature(r/s/y_parity)
  - 代码：core/src/apps/ethereum/onekey/sign_tx_eip7702.py → check_common_fields

- 授权签名字段合法性
  - 作用：保证签名格式正确
  - 限制：y_parity 范围校验；r/s 长度必须为 32 字节
  - 代码：core/src/apps/ethereum/onekey/sign_tx_eip7702.py → check_common_fields

- 撤销（Revoke）支持
  - 作用：清除委托、恢复普通 EOA 状态
  - 限制：零地址作为 revoke 委托允许；遵循与上相同的基础校验
  - 代码：core/src/apps/ethereum/onekey/eip7702_delegators.py（Revoke 条目）
